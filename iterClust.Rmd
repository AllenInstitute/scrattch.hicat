---
title: "iterClust"
output: html_notebook
---

The iterClust package offers functions to preform iterative clustering for single cell RNAseq datasets. The pipeline consists of the following kep steps: high variance gene selection, dimensionality reduction, dimension filtering, and Jaccard-Louvain or hierarchichal (Ward) clustering, followed by cluster merging based on presence of differentially expressed genes. This process was then repeated within each resulting cluster until no more clusters meet differential gene expression or cluster size termination criteria. 

We used tasic 2016 nature neuron science datasets as example to demonstrate the usage of this package. 

First prepare the datasets 

```{r}
library(iterClust)
library(devtools)
install_github("AllenInstitute/tasic2016data") 

library(tasic2016data)
anno <- tasic_2016_anno
counts <- tasic_2016_counts

jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")) 

anno <- tasic_2016_anno
ref.cl = setNames(factor(anno$primary_type), anno$sample_id)
ref.cl.df = as.data.frame(unique(anno[,c("primary_type","broad_type")]))
colnames(ref.cl.df)=c("cluster_label","categorty_label")
row.names(ref.cl.df) = ref.cl.df$cluster_label
ref.cl.df$cluster_color = jet.colors(nrow(ref.cl.df))
```

Convert counts to CPM and take the log2 transformation
```{r}
norm.dat = log2(t(t(counts)/colSums(counts)*10^6)+1)
```

For demo, only use GABA-ergic neurons for clustering. 
```{r}
select.cells=with(anno, sample_id[broad_type=="GABA-ergic Neuron" & primary_type!="unclassified"])
```


The final number of clusters produced by this iterative clustering algorithm is largely determined by the required cell type resolution specified by the user. The cell type resolution is defined by the differential expression (DE) criteria between every pair of clusters. The users can specify these criteria using de_param function. 

Statistical singificance of DE genes are computed by limma, with two key parameters specified below:
padj.th: adjusted pvalue threshold for DE genes.
lfc.th: log2 fold change threshold for DE genes.

We also require DE genes to have relative on/off binary expression pattern, specified by the following parameters:
low.th: the threshold used to determine whether a gene is detected in a given cell or not. This threshold is applied to log2 transformed normalized data. The fault value is 1. Users can specifiy different thresholds for different genes if necessary.
For every pair of clusters (one as foreground, and the other as background), we define q1, and q2 as the proportion of cells detecting the gene in the foregound and background cluster respectively.
q1.th: For up regulated genes, q1 should be greater than q1.th. 
q2.th: For up regulated genes, q2 should be geeater than q2.th. By default q2.th is not set. 
q.diff.th: The difference, defined as abs(q1 - q2)/max(q1, q2) should be greater than q.diff.th. 
The users can also ignore these parameters by setting them to NULL. 

To determine whether two clusters are seperable based on DE genes, we define de.score as the sum of -log10(adjusted Pvalub) for all DE genes. Each gene contributes at most 20 towards the sum. All clusters should have pairwise de.score greater than de.score.th. 


```{r}
de.param = de_param(padj.th=0.05, lfc.th=1, low.th=1, q1.th=0.5, q.diff.th=0.7, de.score.th=60)
```


Technical variation that should be masked during clustering process can be specified by matrix "rm.eigen". If any batch effects are present, you can use the first principle component of batch specific genes as a column in "rm.eigen". QC related factors, such as sequencing depth, gene detection delimits, fraction of reads mapped to transcriptome also, also tend to drive systemetic technical variation in gene expression. You can directly use proper transformation of such QC related variables, or use the first principle component of the genes that correlate with these QC factors. When rm.eigen is specified, any reduced dimension vectors during cluster that have correlation greater than "rm.th" with any columns of rm.eigen are ignored during clustering.

```{r}
gene.counts= colSums(counts>0)
rm.eigen = matrix(log2(gene.counts), ncol=1)
row.names(rm.eigen) = names(gene.counts)
colnames(rm.eigen) = "log2GeneCounts"
```



Perform clustering using WGCNA for dimensional reduction. WGCNA mode is good for detecting rare clusters, provides cleaner cluster boundaries, while PCA is more scalable to large datasets, captures combinatorial marker expression pattern more effectively, and more sensitive to low depth dataset. We recommend using WGCNA for small high coverage datasets, and PCA for large low coverage datasets. 

```{r, echo=FALSE}
set.seed(1)
WGCNA.clust.result <- iter_clust(norm.dat, select.cells=select.cells, dim.method="WGCNA", de.param = de.param, rm.eigen=rm.eigen, rm.th=0.7)
```
To use PCA mode, simply use dim.method = "pca"


Although we checked whether clusters at any iteration can be seperated by DEG, clusters from different iterations can end up quite similar. So it is necessary check whether all the clusters are seperable by DEGs in the end. 
```{r, echo=FALSE}
merge.result=merge_cl(norm.dat, WGCNA.clust.result$cl, rd.dat = t(norm.dat[WGCNA.clust.result$markers, select.cells]), de.param = de.param)
```

Compare and annotate the clusters based on reference cluster annotation. 
```{r, echo=FALSE}
compare.result=compare_annotate(merge.result$cl, ref.cl, ref.cl.df)
compare.result$g
WGCNA.cl = compare.result$cl
WGCNA.cl.df = compare.result$cl.df
```


Perferm clustering on subsampled cells repeatedly to test clustering robustness. 
```{r, echo=FALSE}
d = paste0("subsample")
dir.create(d)
all.cells=select.cells
subsample.result = sapply(1:20,function(i){
  prefix=paste0("iter",i)
  tmp.cells = sample(select.cells, round(0.8*length(select.cells)))
  result <- iter_clust(norm.dat, select.cells=tmp.cells, prefix=prefix, dim.method="WGCNA", de.param = de.param)
  save(result, file=file.path(d, paste0("result.",i,".rda")))
})
```

Collect cell-cell co-clustering probablities.
```{r, echo=FALSE}
result.files=file.path(d, dir(d, "result.*.rda"))
co.result <- collect_co_matrix(result.files, select.cells)
co.ratio <- co.result$co.ratio
cl.list = co.result$cl.list
```

Infer consensus clusters based on cell cell co-clustering matrix.
```{r, echo=FALSE}
consensus.result = iter_consensus_clust(co.ratio, cl.list, norm.dat, select.cells=select.cells, de.param=de.param)
```

Adjust cluster boundaries to optimize with-in cluster co-clustering probabilties
```{r}
consensus.cl = reassign_co_ratio(co.ratio, consensus.result$cl)$cl
```

Plot the heatmap of co-clustering matrix:
```{r}
consensus.cl = reorder_cl(consensus.cl, co.ratio)
tmp=plot_co_matrix(co.ratio, consensus.cl, max.cl.size=50)
```

Double check if all clusters are separable based on DEG genes again. 
```{r}
merge.result=merge_cl(norm.dat, consensus.cl, rd.dat = t(norm.dat[consensus.result$markers,select.cells]), de.param = de.param)
compare.result=compare_annotate(merge.result$cl, cl, cl.df)
compare.result$g
cl = compare.result$cl
cl.df = compare.result$cl.df
```


At this point,  check the cluster annotation cl.df manually to change the cluster labels, colors, and determine if some clusters are outliers. 
```{r}
cl.clean = droplevels(cl)
```
If there are outlier clusters, define cl.clean as the clusters after removing outliers. 


Find the top 50 differentiall expressed (DE) genes between clusters
```{r}
de.markers = select_markers(norm.dat, cl.clean, n.markers=50, de.param = de.param)
select.markers= de.markers$markers
de.genes = de.markers$de.genes
```

Build dendrogram using top DE genes between clusters.
Compute cluster median expression based on the marker genes.
```{r}
cl.med = do.call("cbind",tapply(names(cl), cl, function(x){
  rowMedians(as.matrix(norm.dat[,x]))
}))
row.names(cl.med)=row.names(norm.dat)
```

Determine the preferred order and the colors of clusters
```{r}
l.rank = setNames(1:nrow(cl.df),row.names(cl.df))
l.color = setNames(as.character(cl.df$cluster_color),row.names(cl.df))
```

Build dendrogram for clusters using the cluster-cluster correlation matrix based on cluster medians of marker genes
```{r, echo=FALSE, fig.keep="all"}
dend.result <- build_dend(cl.med[select.markers,levels(cl.clean)],l.rank, l.color,collapse.height=0.001, nboot=100)
dend= dend.result$dend
```

Reorder the clusters based on the dendrogram:
```{r}
cl.clean = setNames(factor(as.character(cl.clean), levels=labels(dend)), names(cl.clean))
cl.df.clean =cl.df[levels(cl.clean),]
```

Plot the dendrogram and cluster-cluster correlation matrix:
```{r, echo=FALSE, fig.keep="all"}
labels(dend) = cl.df[labels(dend),"cluster_label"]
cl.cor = dend.result$cl.cor
plot(dend)
heatmap.3(cl.cor, Rowv=dend, Colv=dend, trace="none",col=jet.colors(100),
          cexCol=0.5,cexRow=0.5,breaks=c(-0.2, 0.2, seq(0.2, 1, length.out=99)))
```

Create tSNE plots:
```{r}
tsne.result <- plot_tSNE_cl(norm.dat, select.markers, cl, cl.df)
tsne.result$p
```

