<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Overview of scrattch hicat • scrattch.hicat</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Overview of scrattch hicat"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">scrattch.hicat</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/scrattch.hicat_release.html">Overview of scrattch hicat</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/AllenInstitute/scrattch.hicat/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->



      </header>





<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Overview of scrattch hicat</h1>
                        <h4 data-toc-skip class="author">Zizhen Yao,
Cindy van Velthoven, Adriana Sedeno-Cortes, Changkyu Lee, Lawrence
Huang</h4>
            
            <h4 data-toc-skip class="date">2020-03-27</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/AllenInstitute/scrattch.hicat/blob/HEAD/vignettes/scrattch.hicat_release.Rmd" class="external-link"><code>vignettes/scrattch.hicat_release.Rmd</code></a></small>
      <div class="hidden name"><code>scrattch.hicat_release.Rmd</code></div>

    </div>

    
    
<p><code>scrattch.hicat</code> offers functions to perform iterative
clustering for single cell RNAseq datasets.</p>
<p>The <code>scrattch.hicat</code> package is one component of the
scrattch suite of packages for <code>S</code>ingle <code>C</code>ell
<code>R</code>NA-seq <code>A</code>nalysis for
<code>T</code>ranscriptomic <code>T</code>ype
<code>CH</code>aracterization from the Allen Institute.
<code>hicat</code> stands for <code>H</code>ierarchical,
<code>I</code>terative <code>C</code>lustering for <code>A</code>nalysis
of <code>T</code>ranscriptomics.</p>
<p><a id="contents"></a> The pipeline consists of the following key
steps:</p>
<ul>
<li><a href="#setup">Dataset formatting and setup</a><br />
</li>
<li><a href="#params">Parameter specification</a><br />
</li>
<li><a href="#clust">Iterative Clutering</a>
<ul>
<li>High variance gene selection<br />
</li>
<li>Dimensionality reduction using PCA or WGCNA<br />
</li>
<li><a href="#filter">Dimension filtering based on QC
correlation</a><br />
</li>
<li>Jaccard-Louvain or hierarchichal (Ward) clustering<br />
</li>
</ul></li>
<li><a href="#merge">Cluster merging based on presence of differentially
expressed genes</a></li>
</ul>
<p>This process is iteratively repeated within each resulting cluster
until no more clusters meet differential gene expression and cluster
size termination criteria.</p>
<p>We can inspect and visualize the results of consensus clustering:</p>
<ul>
<li><a href="#markerplot">Compute marker genes and plot marker
heatmaps</a><br />
</li>
<li><a href="#dendplot">Hierarchical dendrograms</a><br />
</li>
<li><a href="#tsneplot">t-SNE plots</a></li>
</ul>
<p>Consensus clustering was introduced to ensure robustness of
clustering:</p>
<ul>
<li><a href="#boot">Bootstrapping of the iterative clustering
process</a><br />
</li>
<li><a href="#breakdown">Breakdown of consensus clustering</a></li>
</ul>
<p>For this vignette, we use a subset of the dataset published in <a
href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4985242/">Tasic, et
al. (2016) Nature Neuroscience</a>, which is available in the <a
href="https://github.com/AllenInstitute/tasic2016data">tasic2016data
package</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="st">&quot;tasic2016data&quot;</span> <span class="sc">%in%</span> <span class="fu">rownames</span>(<span class="fu">installed.packages</span>())) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">&quot;AllenInstitute/tasic2016data&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tasic2016data)</span></code></pre></div>
<p>This vignette depends on a few other packages, in addition to
<code>scrattch.hicat</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dendextend)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(matrixStats)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Matrix)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(scrattch.hicat)</span></code></pre></div>
<pre><code>#&gt; scrattch.hicat version: 1.0.0</code></pre>
<div id="setup" class="section level2">
<h2>Dataset formatting and setup</h2>
<hr />
<p>First prepare the datasets</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load sample annotations (anno)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>anno <span class="ot">&lt;-</span> tasic_2016_anno</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Make a data.frame of unique cluster id, type, color, and broad type</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>ref.cl.df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">unique</span>(anno[,<span class="fu">c</span>(<span class="st">&quot;primary_type_id&quot;</span>, <span class="st">&quot;primary_type_label&quot;</span>, <span class="st">&quot;primary_type_color&quot;</span>, <span class="st">&quot;broad_type&quot;</span>)]))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Standardize cluster annoation with cluster_id, cluster_label and cluster_color. These are the required fields to visualize clusters properly.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(ref.cl.df)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;cluster_id&quot;</span>, <span class="st">&quot;cluster_label&quot;</span>, <span class="st">&quot;cluster_color&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort by cluster_id</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>ref.cl.df <span class="ot">&lt;-</span> ref.cl.df[<span class="fu">order</span>(ref.cl.df<span class="sc">$</span>cluster_id),]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(ref.cl.df) <span class="ot">&lt;-</span> ref.cl.df<span class="sc">$</span>cluster_id</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>ref.cl <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">factor</span>(anno<span class="sc">$</span>primary_type_id), anno<span class="sc">$</span>sample_name)</span></code></pre></div>
<p>Convert counts to CPM and take log2 transformation</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>norm.dat <span class="ot">&lt;-</span> <span class="fu">log2</span>(<span class="fu">cpm</span>(tasic_2016_counts)<span class="sc">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>If you have a very large matrix, we recommend you convert it to a
sparse matrix using the Matrix package to save memory:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>norm.dat <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="fu">cpm</span>(tasic_2016_counts), <span class="at">sparse =</span> <span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>norm.dat<span class="sc">@</span>x <span class="ot">&lt;-</span> <span class="fu">log2</span>(norm.dat<span class="sc">@</span>x<span class="sc">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>For this demo, we’ll select a small subset of CGE-derived
interneurons for clustering. This gives us a set of 284 single-cell
transcriptomic profiles to work with.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>select.cells <span class="ot">&lt;-</span> <span class="fu">with</span>(anno, sample_name[primary_type_label<span class="sc">!=</span><span class="st">&quot;unclassified&quot;</span> <span class="sc">&amp;</span> <span class="fu">grepl</span>(<span class="st">&quot;Igtp|Ndnf|Vip|Sncg|Smad3&quot;</span>,primary_type_label)])</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="params" class="section level2">
<h2>Parameter specification</h2>
<hr />
<p>The final number of clusters produced by this iterative clustering
algorithm is largely determined by the required cell type resolution
specified by the user. The cell type resolution is defined by
differential expression (DE) criteria between every pair of clusters.
The users can specify these criteria ahead of time, for reuse in hicat
functions by using the <code>de_param()</code> function.</p>
<p>We compute statistical singificance of DE genes using
<code>limma</code>, with two key parameters specified below:<br />
<strong>padj.th</strong>: adjusted p value threshold for DE genes.<br />
<strong>lfc.th</strong>: log2 fold change threshold for DE genes.</p>
<p>We also require DE genes to have a relatively binary (on/off)
expression pattern, specified by the following parameters:<br />
<strong>low.th</strong>: The minimum value used to determine whether a
gene is detected in a given cell or not. This threshold is applied to
log2-transformed, normalized data. The default value is 1. Users can
specifiy different thresholds for different genes if necessary.<br />
For every pair of clusters (one as foreground, and the other as
background), we define q1, and q2 as the proportion of cells with
expression &gt; <strong>low.th</strong> in the foregound and background
cluster respectively.<br />
<strong>q1.th</strong>: For up regulated genes, q1 should be greater
than q1.th in the <em>foreground</em> set.<br />
<strong>q2.th</strong>: For up regulated genes, q2 should be smaller
than q2.th in the <em>background</em> set.<br />
<strong>q.diff.th</strong>: The difference, defined as abs(q1 -
q2)/max(q1, q2) should be greater than q.diff.th.<br />
By default, <strong>q1.th</strong> = 0.5, <strong>q2.th</strong> = NULL,
and <strong>q.diff.th </strong>= 0.7.</p>
<p>The user can also ignore these parameters by setting them all to
NULL.<br />
For high-depth datasets, like those generated using SMARTerV4 or
Smart-Seq2, we recommend starting with <strong>q1.th</strong> = 0.5
.<br />
For low-depth datasets, like those generated using Dropseq or 10X
Genomics, we recommend starting with <strong>q1.th</strong> = 0.3 due to
the generally lower gene detection per cell in these datasets.<br />
When focusing on discrete cell types, set <strong>q.diff.th</strong>
closer to 1.<br />
If splitting cell types based on graded gene expression variation is of
interest, adjust <strong>q.diff.th</strong> closer to 0.</p>
<p>To determine whether two clusters are seperable based on DE genes, we
define <strong>de.score</strong> as the sum of -log10(adjusted Pvalue)
for all DE genes. Each gene contributes at most 20 towards the sum. All
clusters should have pairwise de.score greater than
<strong>de.score.th</strong>.<br />
For small datasets (#cells &lt; 1000), we recommend
<strong>de.score.th</strong> = 40.<br />
For large datasets (#cells &gt; 10000), we recommend
<strong>de.score.th</strong> = 150.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>de.param <span class="ot">&lt;-</span> <span class="fu">de_param</span>(<span class="at">padj.th     =</span> <span class="fl">0.05</span>, </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">lfc.th      =</span> <span class="dv">1</span>, </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">low.th      =</span> <span class="dv">1</span>, </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">q1.th       =</span> <span class="fl">0.5</span>, </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">q.diff.th   =</span> <span class="fl">0.7</span>, </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                     <span class="at">de.score.th =</span> <span class="dv">40</span>)</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="clust" class="section level2">
<h2>Perform clustering</h2>
<hr />
<p><code>scrattch.hicat</code> can perform clustering using WGCNA or PCA
for dimensionality reduction. WGCNA mode is good for detecting rare
clusters and provides cleaner cluster boundaries, while PCA is more
scalable to large datasets, captures combinatorial marker expression
patterns more effectively, and is more sensitive to low-depth
datasets.</p>
<p>We recommend using WGCNA for smaller, high-depth datasets (&lt; 4,000
samples; &gt; 5,000 genes detecter per sample), and PCA for large or
low-coverage datasets (&gt; 4,000 samples or &lt; 5,000 genes detected
per sample). Another consideration is that WGCNA is considerably slower
than PCA. Note that while the whole clustering pipeline scales quite
well with the number of cells, the running time heavily depends on the
cell type complexity as clustering is iterative.</p>
<p>First, let us just run one round of clustering using WGCNA mode using
high stringency to check the broad cell types</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>onestep.result <span class="ot">&lt;-</span> <span class="fu">onestep_clust</span>(norm.dat, </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">select.cells =</span> select.cells, </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">dim.method =</span> <span class="st">&quot;WGCNA&quot;</span>, </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">de.param =</span> <span class="fu">de_param</span>(<span class="at">de.score.th=</span><span class="dv">500</span>))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  ..done.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Finding nearest neighbors...DONE ~ 0.003 s</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Compute jaccard coefficient between nearest-neighbor sets...DONE ~ 0.02 s</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Build undirected graph from the weighted links...DONE ~ 0.023 s</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Run louvain clustering on the graph ...DONE ~ 0.008 s</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Return a community class</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   -Modularity value: 0.7715781 </span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   -Number of clusters: 9</span></span></code></pre></div>
<p><a id="markerplot"></a></p>
<p>Take a quick look at the clustering heatmap</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>display.result <span class="ot">=</span> <span class="fu">display_cl</span>(onestep.result<span class="sc">$</span>cl, norm.dat, <span class="at">plot=</span><span class="cn">TRUE</span>, <span class="at">de.param=</span>de.param)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in is.null(Rowv) || is.na(Rowv): &#39;length(x) = 2 &gt; 1&#39; in coercion to</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &#39;logical(1)&#39;</span></span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Apply iterative clustering pipeline for finer splits based on
existing clusters using more relaxed threshold.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>WGCNA.clust.result <span class="ot">&lt;-</span> <span class="fu">iter_clust</span>(norm.dat, </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">select.cells =</span> select.cells, </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">dim.method =</span> <span class="st">&quot;WGCNA&quot;</span>, </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">de.param =</span> de.param, </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                               <span class="at">result=</span>onestep.result)</span></code></pre></div>
<p>You can apply iterative clustering pipeline from scratch.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>WGCNA.clust.result <span class="ot">&lt;-</span> <span class="fu">iter_clust</span>(norm.dat, </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">select.cells =</span> select.cells, </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">dim.method =</span> <span class="st">&quot;WGCNA&quot;</span>, </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">de.param =</span> de.param)</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="filter" class="section level2">
<h2>Eliminate technical artfacts at dimension reduction state</h2>
<hr />
<p>Technical variation that should be masked during the clustering
process can be specified using a matrix that we term
<strong>rm.eigen</strong>. If batch effects are present, you can use the
first principle component of batch-specific genes as a column in
<strong>rm.eigen</strong>.</p>
<p>QC-related factors, such as sequencing depth, gene detection limits,
and fraction of reads mapped to transcriptome also tend to correlate
with systemetic technical variation in gene expression.<br />
You can directly use proper transformation of these QC-related
variables, or use the first principle component of the genes that
correlate with these QC factors. The latter approach tends to work
better with real datasets. When <strong>rm.eigen</strong> is specified,
any reduced-dimension vectors during clustering that have correlation
greater than <strong>rm.th</strong> with any columns of
<strong>rm.eigen</strong> are ignored during clustering.</p>
<p>We recommend that users to first explore their data by running the
clustering pipeline without setting <strong>rm.eigen</strong>. If any
batch specific or QC-driven clusters appear to cause problems, the user
can create <strong>rm.eigen</strong> as demonstrated below, and rerun
the pipeline.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>gene.counts <span class="ot">&lt;-</span> <span class="fu">colSums</span>(norm.dat <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>rm.eigen <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">log2</span>(gene.counts), <span class="at">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(rm.eigen) <span class="ot">&lt;-</span> <span class="fu">names</span>(gene.counts)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(rm.eigen) <span class="ot">&lt;-</span> <span class="st">&quot;log2GeneCounts&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>WGCNA.clust.result <span class="ot">&lt;-</span> <span class="fu">iter_clust</span>(norm.dat, </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">select.cells =</span> select.cells, </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">dim.method =</span> <span class="st">&quot;WGCNA&quot;</span>, </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">de.param =</span> de.param,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                               <span class="at">rm.eigen =</span> rm.eigen)</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="merge" class="section level2">
<h2>Cluster merging based on presence of differentially expressed
genes</h2>
<hr />
<p>Throughout the iterative clustering process performed by
<code>iter_clust()</code>, the function checked whether clusters at any
iteration can be seperated by DEG. However, clusters from different
iterations can end up very similar. Thus, it is necessary to check
whether all the clusters are seperable by DEGs in the end. Clusters are
merged in an order defined by the pairs of clusters that are nearest
neighbors, which are computed in a reduced dimension space defined by
<strong>rd.dat</strong>.</p>
<p>Here, we use the set of markers produced by <code>iter_clust()</code>
to define the reduced dimensions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>WGCNA.merge.result <span class="ot">&lt;-</span> <span class="fu">merge_cl</span>(norm.dat, </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">cl =</span> WGCNA.clust.result<span class="sc">$</span>cl, </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">rd.dat =</span> <span class="fu">t</span>(norm.dat[WGCNA.clust.result<span class="sc">$</span>markers, select.cells]),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">de.param =</span> de.param)</span></code></pre></div>
<p>Alternatively, the transpose of rd.dat could be specified as
“rd.dat.t”:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>WGCNA.merge.result <span class="ot">&lt;-</span> <span class="fu">merge_cl</span>(norm.dat, </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">cl =</span> WGCNA.clust.result<span class="sc">$</span>cl, </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">rd.dat.t =</span> norm.dat[WGCNA.clust.result<span class="sc">$</span>markers, select.cells],</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">de.param =</span> de.param)</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="annotate" class="section level2">
<h2>Compare and annotate clusters against reference cluster
annotation</h2>
<hr />
<p>In this demo, we have previously derived cluster labels from Tasic,
et al. (2016). To see how these cluster calls match up to those
generated by <code>scrattch.hicat</code>, we can compare and annotate
the clusters based on the reference cluster annotation.</p>
<pre><code>#&gt; [1] 50</code></pre>
<p><img src="scrattch.hicat_release_files/figure-html/Compare%20to%20benchmark-1.png" width="624" /></p>
<p>Note that the clustering differs slightly from the reference
clusters. Particularly, the original Ndnf Cxcl14 is split into two
clusters, and one of this cluster also contain cells from Vip Gpc3
cluster. Based on analysis based on a bigger dataset, we know that the
cell type diversities for CGE-derived interneurons are richer than what
we described here, and this clustering analysis is far from saturation
due to small number of cells.</p>
<p>Now Let’s compute DE genes between every pair of clusters. To
generate the heatmap, use the top 20 DE genes by default. If you have
many clusters, the heatmap can be too large to display. The users may
choose different “n.markers”</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>display.result <span class="ot">=</span> <span class="fu">display_cl</span>(cl, norm.dat, <span class="at">plot=</span><span class="cn">TRUE</span>, <span class="at">de.param=</span>de.param, <span class="at">min.sep=</span><span class="dv">4</span>, <span class="at">n.markers=</span><span class="dv">20</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in is.null(Rowv) || is.na(Rowv): &#39;length(x) = 2 &gt; 1&#39; in coercion to</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &#39;logical(1)&#39;</span></span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>de.genes<span class="ot">=</span> display.result<span class="sc">$</span>de.genes</span></code></pre></div>
<p>At this point, check the clusters manually to determine if some
clusters are outliers. Define cl.clean as the clusters after removing
outliers.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>cl.clean <span class="ot">&lt;-</span> <span class="fu">droplevels</span>(cl)</span></code></pre></div>
<p><a id="dendplot"></a> We find it helpful to use hierarchical
structure to categorize cell types at different resolution. To build
dendrogram, we use cluster-cluster correlation matrix based on cluster
medians of the top 50 genes between every pair of clusters with
<code>select_markers()</code> and <code>build_dend()</code>. The
confidence of each branch point can be estimated by bootstrap approach
implemented by pvclust package, which is encapsulated by
<code>build_dend()</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>select.markers <span class="ot">=</span> <span class="fu">select_markers</span>(norm.dat, cl.clean, <span class="at">de.genes=</span>de.genes,<span class="at">n.markers=</span><span class="dv">50</span>)<span class="sc">$</span>markers</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>cl.med <span class="ot">&lt;-</span> <span class="fu">get_cl_medians</span>(norm.dat[select.markers,], cl)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="do">##The prefered order for the leaf nodes.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>l.rank <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(cl.df), <span class="fu">row.names</span>(cl.df))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="do">##Color of the leaf nodes.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>l.color <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">as.character</span>(cl.df<span class="sc">$</span>cluster_color), <span class="fu">row.names</span>(cl.df))</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>dend.result <span class="ot">&lt;-</span> <span class="fu">build_dend</span>(cl.med[,<span class="fu">levels</span>(cl.clean)],</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>                          <span class="at">cl.cor=</span><span class="cn">NULL</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>                          l.rank, </span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>                          l.color,</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>                          <span class="at">nboot =</span> <span class="dv">100</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>dend <span class="ot">&lt;-</span> dend.result<span class="sc">$</span>dend</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="do">###attach cluster labels to the leafs of the tree </span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>dend.labeled <span class="ot">=</span> dend</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="fu">labels</span>(dend.labeled) <span class="ot">&lt;-</span> cl.df[<span class="fu">labels</span>(dend), <span class="st">&quot;cluster_label&quot;</span>]</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dend.labeled)</span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/Build%20dendrogram-1.png" width="672" /></p>
<p>Reorder the clusters based on the dendrogram:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>cl.clean <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">factor</span>(<span class="fu">as.character</span>(cl.clean), <span class="at">levels =</span> <span class="fu">labels</span>(dend)), <span class="fu">names</span>(cl.clean))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>cl.df.clean <span class="ot">&lt;-</span> cl.df[<span class="fu">levels</span>(cl.clean),]</span></code></pre></div>
<p>Plot cluster-cluster correlation matrix:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>cl.cor <span class="ot">&lt;-</span> dend.result<span class="sc">$</span>cl.cor</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(cl.cor) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(cl.cor) <span class="ot">&lt;-</span> cl.df[<span class="fu">row.names</span>(cl.cor), <span class="st">&quot;cluster_label&quot;</span>]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">heatmap.3</span>(cl.cor,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>          <span class="at">Rowv =</span> dend, <span class="at">Colv =</span> dend,</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>          <span class="at">trace =</span> <span class="st">&quot;none&quot;</span>, <span class="at">col =</span> <span class="fu">heat.colors</span>(<span class="dv">100</span>),<span class="at">cexRow=</span><span class="fl">0.8</span>, <span class="at">cexCol=</span><span class="fl">0.8</span>,</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>          <span class="at">breaks =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="fu">seq</span>(<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="at">length.out =</span> <span class="dv">99</span>)))</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in is.null(Rowv) || is.na(Rowv): &#39;length(x) = 2 &gt; 1&#39; in coercion to</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &#39;logical(1)&#39;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in is.null(Colv) || is.na(Colv): &#39;length(x) = 2 &gt; 1&#39; in coercion to</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &#39;logical(1)&#39;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Warning in Colv == &quot;Rowv&quot; &amp;&amp; !isTRUE(Rowv): &#39;length(x) = 2 &gt; 1&#39; in coercion to</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; &#39;logical(1)&#39;</span></span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/Plot%20the%20correlation%20heatmap-1.png" width="480" /></p>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="tsneplot" class="section level2">
<h2>t-SNE plots</h2>
<hr />
<p>Generate t-SNE coordinates and a plot using
<code>plot_tsne_cl()</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>tsne.result <span class="ot">&lt;-</span> <span class="fu">plot_tsne_cl</span>(norm.dat, select.markers, cl, cl.df, <span class="at">fn.size=</span><span class="dv">5</span>, <span class="at">cex=</span><span class="dv">1</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Loading required package: Rtsne</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>tsne.df <span class="ot">=</span> tsne.result<span class="sc">$</span>tsne.df</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>tsne.result<span class="sc">$</span>g</span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/tsne%20plot-1.png" width="576" /></p>
<p>Plot expression of a set of genes using the t-SNE coordinates with
<code>plot_tSNE_gene()</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>tsne.df <span class="ot">&lt;-</span> tsne.result<span class="sc">$</span>tsne.df</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="do">## 6330527O06Rik is alias for Lamp5, and A930038C07Rik is alais for Ndnf</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>markers <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Vip&quot;</span>,<span class="st">&quot;6330527O06Rik&quot;</span>,<span class="st">&quot;Sncg&quot;</span>,<span class="st">&quot;Cxcl14&quot;</span>,<span class="st">&quot;Gpc3&quot;</span>,<span class="st">&quot;A930038C07Rik&quot;</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>gene.plots <span class="ot">&lt;-</span> <span class="fu">plot_tSNE_gene</span>(tsne.df, norm.dat, markers)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="fu">multiplot</span>(<span class="at">plotlist =</span> gene.plots, <span class="at">cols =</span> <span class="dv">3</span>)</span></code></pre></div>
<p><img src="scrattch.hicat_release_files/figure-html/tSNE%20expression,%20-1.png" width="672" /></p>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="boot" class="section level2">
<h2>Bootstrapping for Consensus clustering</h2>
<hr />
<p>The iterative clustering pipeline tends to produce many clusters,
with increased uncertainty as we try to split the clusters at finer
resolution. Therefore, it is important to assess the robustness of
clustering results. We address this problem by performing clustering
many times on 80% of randomly subsampled cells, keep track of how often
each cell is clustered with each other cell (a cell-cell co-clustering
matrix), and use these frequencies of cell-cell co-clustering to infer
consensus clustering. We also compute statistics to evaluate our
confidence in the seperation between every pair of consensus clusters.
<code>run_consensus_clust()</code> is a convenient wrapper function for
performing this bootstrapped, iterative clustering process. For faster
execution, we use “PCA” mode.</p>
<p>If you have a multi-core computer, this function can be run in
parallel by setting <strong>mc.cores</strong> to the number of cores you
can use.<br />
Note that this can result in high memory consumption with a high number
of parallel processes. Try using small number of cores first to monitor
the memory consumption:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">run_consensus_clust</span>(norm.dat, </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>                              <span class="at">niter =</span> <span class="dv">20</span>, </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">de.param =</span> de.param, </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>                              <span class="at">rm.eigen =</span> rm.eigen, </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>                              <span class="at">dim.method =</span> <span class="st">&quot;pca&quot;</span>, </span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                              <span class="at">output_dir =</span> <span class="st">&quot;subsample_PCA&quot;</span>, </span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                              <span class="at">mc.cores =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>Compare the consensus clustering results against the reference
clusters, and we see that PCA mode produce clusters at lower resolution
than WGCNA mode. Small clusters like Igtp, which has very distinct
transcriptional signature, still got merged with other clusters.</p>
<pre><code>#&gt; [1] 50</code></pre>
<p><img src="scrattch.hicat_release_files/figure-html/Compare%20consensus%20to%20benchmark-1.png" width="576" /></p>
<p><a href="#contents">Back to top</a></p>
</div>
<div id="breakdown" class="section level2">
<h2>Breakdown of consensus clustering</h2>
<hr />
<p><code>run_consensus_clust()</code> is a wrapper function that
performs the following steps:</p>
<ul>
<li>Perform clustering on subsampled cells:</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;subsample_PCA&quot;</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dir.create</span>(d)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>n_iter <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>all.cells <span class="ot">&lt;-</span> select.cells</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>subsample.result <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>n_iter, </span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">function</span>(i) {</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                             prefix <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;iter&quot;</span>,i)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                             tmp.cells <span class="ot">&lt;-</span> <span class="fu">sample</span>(all.cells, <span class="fu">round</span>(<span class="fl">0.8</span> <span class="sc">*</span> <span class="fu">length</span>(all.cells)))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>                             result <span class="ot">&lt;-</span> <span class="fu">iter_clust</span>(norm.dat, </span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>                                                  <span class="at">select.cells =</span> tmp.cells, </span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>                                                  <span class="at">prefix =</span> prefix, </span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>                                                  <span class="at">dim.method =</span> <span class="st">&quot;pca&quot;</span>, </span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>                                                  <span class="at">de.param =</span> de.param)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">save</span>(result, <span class="at">file =</span> <span class="fu">file.path</span>(d, <span class="fu">paste0</span>(<span class="st">&quot;result.&quot;</span>, i, <span class="st">&quot;.rda&quot;</span>)))</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>                           }</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<ul>
<li>Collect cell-cell co-clustering probablities:</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>result.files <span class="ot">&lt;-</span> <span class="fu">file.path</span>(d, <span class="fu">dir</span>(d, <span class="st">&quot;result.*.rda&quot;</span>))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>co.result <span class="ot">&lt;-</span> <span class="fu">collect_subsample_cl_matrix</span>(norm.dat, result.files, all.cells)</span></code></pre></div>
<ul>
<li>Infer consensus clusters based on the cell-cell co-clustering
matrix:</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>consensus.result <span class="ot">&lt;-</span> <span class="fu">iter_consensus_clust</span>(<span class="at">cl.list =</span> co.result<span class="sc">$</span>cl.list, </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">cl.mat =</span> co.result<span class="sc">$</span>cl.mat, <span class="at">norm.dat =</span> norm.dat, <span class="at">select.cells =</span> all.cells, </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">de.param =</span> de.param, <span class="at">merge.type =</span> <span class="st">&quot;directional&quot;</span>, <span class="at">method =</span> <span class="st">&quot;auto&quot;</span>, </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">result =</span> <span class="cn">NULL</span>)</span></code></pre></div>
<ul>
<li>Adjust cluster boundaries to optimize within-cluster co-clustering
probabilties:</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>refine.result <span class="ot">&lt;-</span> <span class="fu">refine_cl</span>(consensus.result<span class="sc">$</span>cl, </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">cl.mat =</span> co.result<span class="sc">$</span>cl.mat, </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">tol.th =</span> <span class="fl">0.01</span>, </span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                           <span class="at">confusion.th =</span> <span class="fl">0.8</span>, </span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>                           <span class="at">min.cells =</span> de.param<span class="sc">$</span>min.cells)</span></code></pre></div>
<ul>
<li>Double-check if all clusters are separable based on DE genes
again:</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>merge.result <span class="ot">&lt;-</span> <span class="fu">merge_cl</span>(norm.dat, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>                         refine.result<span class="sc">$</span>cl, </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">rd.dat.t =</span> norm.dat[consensus.result<span class="sc">$</span>markers,select.cells], </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">de.param =</span> de.param,</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">merge.type =</span> <span class="st">&quot;directional&quot;</span>, </span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">return.markers =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p><a href="#contents">Back to top</a></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p><p>Developed by Zizhen Yao, Lucas Graybuck, Trygve Bakken, Cindy van Velthoven, Jeremy Miller, Adriana Sedeno-Cortes, Changkyu Lee, Lawrence Huang, Saroja Somasundaram.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer></div>






  </body></html>
