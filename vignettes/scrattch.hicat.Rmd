---
title: "scrattch.hicat"
output:
  html_document: default
  html_notebook: default
---

The scrattch.hicat package offers functions to preform iterative clustering for single cell RNAseq datasets. The pipeline consists of the following kep steps: high variance gene selection, dimensionality reduction, dimension filtering, and Jaccard-Louvain or hierarchichal (Ward) clustering, followed by cluster merging based on presence of differentially expressed genes. This process was then repeated within each resulting cluster until no more clusters meet differential gene expression and cluster size termination criteria. 

We used tasic 2016 nature neuron science datasets as an example to demonstrate the usage of this package. 

First prepare the datasets 
```{r}
library(scrattch.hicat)
library(devtools)
install_github("AllenInstitute/tasic2016data") 

jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")) 
library(tasic2016data)
anno <- tasic_2016_anno
ref.cl.df = as.data.frame(unique(anno[,c("primary_type_id", "primary_type", "primary_type_color","broad_type")]))
colnames(ref.cl.df)[1:3]=c("cluster_id","cluster_label","cluster_color")
ref.cl.df = ref.cl.df[order(ref.cl.df$cluster_id),]
row.names(ref.cl.df) = ref.cl.df$cluster_id
ref.cl = setNames(factor(anno$primary_type_id), anno$sample_id)
```

Convert counts to CPM and take log2 transformation
```{r}
norm.dat = log2(cpm(tasic_2016_counts)+1)
```
If you have a very large matrix, convert it to sparse matrix to save memory
```{r}
library(Matrix)
norm.dat = cpm(Matrix(tasic_2016_counts,sparse=TRUE))
norm.dat@x = log2(norm.dat@x+1)
```



For demo, only use GABA-ergic neurons for clustering. 
```{r}
select.cells=with(anno, sample_id[broad_type=="GABA-ergic Neuron" & primary_type!="unclassified"])
```


The final number of clusters produced by this iterative clustering algorithm is largely determined by the required cell type resolution specified by the user. The cell type resolution is defined by the differential expression (DE) criteria between every pair of clusters. The users can specify these criteria using de_param function. 

We compute statistical singificance of DE genes  by limma, with two key parameters specified below:  
padj.th: adjusted pvalue threshold for DE genes.  
lfc.th: log2 fold change threshold for DE genes.  

We also require DE genes to have relatively on/off binary expression pattern, specified by the following parameters:  
low.th: the threshold used to determine whether a gene is detected in a given cell or not. This threshold is applied to log2 transformed normalized data. The fault value is 1. Users can specifiy different thresholds for different genes if necessary.  
For every pair of clusters (one as foreground, and the other as background), we define q1, and q2 as the proportion of cells detecting the gene in the foregound and background cluster respectively.  
q1.th: For up regulated genes, q1 should be greater than q1.th.  
q2.th: For up regulated genes, q2 should be smaller than q2.th.  
q.diff.th: The difference, defined as abs(q1 - q2)/max(q1, q2) should be greater than q.diff.th.   
By default, q1.th = 0.5, q.diff.th = 0.7, and q2.th = NULL.   

The users can also ignore these parameters by setting them all to NULL.   
For high depth dataset like Smartseq, we recomment q1.th = 0.5  
For low depth dataset like Dropseq or 10X, we recomment q1.th=0.3    
When focusing on discrete cell type heterogenity, set q.diff.th close to 1.  
If graident differences are of interest, set q.diff.th close to 0.   
  
  
To determine whether two clusters are seperable based on DE genes, we define de.score as the sum of -log10(adjusted Pvalue) for all DE genes. Each gene contributes at most 20 towards the sum. All clusters should have pairwise de.score greater than de.score.th.  
For small datasets (#cells < 1000), we recommend de.score.th = 50.   
For large datasets (#cells > 10000), we recommend de.score.th = 150  

```{r}
de.param = de_param(padj.th=0.05, lfc.th=1, low.th=1, q1.th=0.5, q.diff.th=0.7, de.score.th=50)
```

Technical variation that should be masked during clustering process can be specified by matrix "rm.eigen". If any batch effects are present, you can use the first principle component of batch specific genes as a column in "rm.eigen". QC related factors, such as sequencing depth, gene detection delimits, fraction of reads mapped to transcriptome, also tend to correlate with systemetic technical variation in gene expression. You can directly use proper transformation of such QC related variables, or use the first principle component of the genes that correlate with these QC factors. The latter approach tends to work better with real datasets. When rm.eigen is specified, any reduced dimension vectors during clustering that have correlation greater than "rm.th" with any columns of rm.eigen are ignored during clustering. 
We recommend the users to first run the clustering pipeline without setting rm.eigen. If any batch specific or QC drive clusters cause any issues, the users can create "rm.eigen" and rerun the pipeline. 

```{r,echo=FALSE}
gene.counts= colSums(norm.dat>0)
rm.eigen = matrix(log2(gene.counts), ncol=1)
row.names(rm.eigen) = names(gene.counts)
colnames(rm.eigen) = "log2GeneCounts"
```


Perform clustering using WGCNA for dimensional reduction. WGCNA mode is good for detecting rare clusters, provides cleaner cluster boundaries, while PCA is more scalable to large datasets, captures combinatorial marker expression pattern more effectively, and more sensitive to low depth dataset. We recommend using WGCNA for small high quality datasets, and PCA for large low coverage datasets. Note that WGCNA is considerably slower than PCA mode. The example we show here does not contain many cells, so we use WGCNA mode for better resolution.   

```{r, message=FALSE, warning=FALSE, results="hide", echo=FALSE}
set.seed(12345)
WGCNA.clust.result <- iter_clust(norm.dat, select.cells=select.cells, dim.method="WGCNA", de.param = de.param, rm.eigen=rm.eigen)
```
To use PCA mode, simply use dim.method = "pca".  


Although we checked whether clusters at any iteration can be seperated by DEG, clusters from different iterations can end up quite similar. So it is necessary to check whether all the clusters are seperable by DEGs in the end. 
Clusters that merged in the order defined by the nearest neighbors. Nearest neighbors are computed in a reduced dimension space defined by rd.dat. Here, we used the markers produced by iter_clust to define the reduced dimension. 
```{r, message=FALSE, warning=FALSE, result="hide", echo=FALSE}
merge.result=merge_cl(norm.dat, WGCNA.clust.result$cl, rd.dat = t(norm.dat[WGCNA.clust.result$markers, select.cells]), de.param = de.param)
```

Compare and annotate the clusters based on reference cluster annotation. 
```{r, echo=FALSE}
compare.result=compare_annotate(merge.result$cl, ref.cl, ref.cl.df)
compare.result$g
WGCNA.cl = compare.result$cl
WGCNA.cl.df = compare.result$cl.df
```


Iterative clustering pipeline tend to produce many clusters, and uncertainty increases as we try to split the clusters at finer resolution. Therefore, it is important to assess the robustness of clustering result. We solve this problem by performing clustering many times on 80% of subsampled cells, compute cell-cell co-clustering matrix, and finally infer consensus clustering. We also compute statistics to eveluate confidence of seperation between every pair of consensus clusters.


```{r, echo=FALSE}
set.seed(12345)
result <- run_consensus_clust(norm.dat[,select.cells], niter=20, de.param =de.param, rm.eigen=rm.eigen, dim.method="WGCNA", output_dir="subsample_WGCNA")
```


If you have a multi-core computer, this function can be run in parallel by setting mc.cores to the number of cores you can use. Please try using small number of cpus first to monitor the momery consumption.  
```{r, eval=FALSE, echo=FALSE}
result <- run_consensus_clust(norm.dat, niter=50, de.param =de.param, rm.eigen=rm.eigen, dim.method="WGCNA", mc.cores=4)
```

Compare the consensus clustering result with the reference clusters
```{r, echo=FALSE}
compare.result=compare_annotate(result$cl.result$cl, ref.cl, ref.cl.df)
compare.result$g
cl = compare.result$cl
cl.df = compare.result$cl.df
```




run_consensus_clust is a wrapper function that performs the following tasks:
- Perform clustering on subsampled cells
```{r, echo=FALSE, eval=FALSE}
d = paste0("subsample_WGCNA")
dir.create(d)
all.cells=select.cells
subsample.result = sapply(1:50,function(i){
  prefix=paste0("iter",i)
  tmp.cells = sample(all.cells, round(0.8*length(all.cells)))
  result <- iter_clust(norm.dat, select.cells=tmp.cells, prefix=prefix, dim.method="WGCNA", de.param = de.param)
  save(result, file=file.path(d, paste0("result.",i,".rda")))
})
```

- Collect cell-cell co-clustering probablities.
```{r, echo=FALSE, eval=FALSE}
result.files=file.path(d, dir(d, "result.*.rda"))
co.result <- collect_co_matrix_sparseM(norm.dat, result.files, all.cells)
co.ratio <- co.result$co.ratio
cl.list = co.result$cl.list
```

- Infer consensus clusters based on cell cell co-clustering matrix.
```{r, echo=FALSE, eval=FALSE}
consensus.result = iter_consensus_clust(co.ratio, cl.list, norm.dat, select.cells=select.cells, de.param=de.param)
```

- Adjust cluster boundaries to optimize with-in cluster co-clustering probabilties
```{r, echo=FALSE, eval= FALSE}
refine.result = refine_cl(consensus.result$cl, co.ratio=co.ratio, tol.th=0.005, confusion.th=0.8)
```

- Double check if all clusters are separable based on DEG genes again. 
```{r, echo=FALSE, eval=FALSE}
merge.result=merge_cl(norm.dat, refine.result$cl, rd.dat = t(norm.dat[consensus.result$markers,select.cells]), de.param = de.param)
```



At this point,  check the cluster annotation cl.df manually to change the cluster labels, colors, and determine if some clusters are outliers. 
If there are outlier clusters, define cl.clean as the clusters after removing outliers. 
```{r}
cl.clean = droplevels(cl)
```



Compute DE genes between every pair of clusters, and plot the heatmap using top 20 DE genes between every pair. If you have many clusters, the heatmap will be very large. Choose small number of n.markers, and use "max.cl.size" to sample subsets of cells for plotting.  
```{r}
display.result=display_cl(cl.clean, norm.dat, n.markers=20, plot=TRUE)
de.genes = display.result$de.genes
```



Build dendrogram for clusters using the cluster-cluster correlation matrix based on cluster medians of the top 50 genes between every pair of clusters
```{r, echo=FALSE}
select.markers = select_markers(norm.dat, cl, n.markers=50, de.genes=de.genes)$markers
cl.med = get_cl_medians(norm.dat[select.markers,], cl)
##The prefered order for the leaf nodes.
l.rank = setNames(1:nrow(cl.df),row.names(cl.df))
##Color of the leaf nodes.
l.color = setNames(as.character(cl.df$cluster_color),row.names(cl.df))
dend.result <- build_dend(cl.med[,levels(cl.clean)],l.rank, l.color,nboot=100)
dend= dend.result$dend
```

Reorder the clusters based on the dendrogram:
```{r}
cl.clean = setNames(factor(as.character(cl.clean), levels=labels(dend)), names(cl.clean))
cl.df.clean =cl.df[levels(cl.clean),]
```

Plot the dendrogram and cluster-cluster correlation matrix:
```{r, echo=FALSE, fig.keep="all"}
library(dendextend)
labels(dend) = cl.df[labels(dend),"cluster_label"]
cl.cor = dend.result$cl.cor
row.names(cl.cor) = colnames(cl.cor) = cl.df[row.names(cl.cor),"cluster_label"]
plot(dend)
heatmap.3(cl.cor, Rowv=dend, Colv=dend, trace="none",col=jet.colors(100),
          cexCol=0.5,cexRow=0.5,breaks=c(-0.2, 0.2, seq(0.2, 1, length.out=99)))
```


Create tSNE plots:
```{r,fig.keep="all"}
tsne.result <- plot_tsne_cl(norm.dat, select.markers, cl, cl.df)
tsne.result$g
```

Plot gene expression on tSNE
```{r}
tsne.df = tsne.result$tsne.df
markers=c("Slc17a7","Gad2","Sst","Chodl","Myh8","Pvalb","Vip","6330527O06Rik","Sncg","Cxcl14")
gene.plots = plot_tsne_gene(tsne.df, norm.dat, markers)
multiplot(plotlist=gene.plots, cols=5)
```

Plot the heatmap of co-clustering matrix. To reduce the size of image, randomly sampled up to 50 cells per cluster
```{r}
co.ratio = result$co.result$co.ratio
tmp=plot_co_matrix(co.ratio, cl.clean, max.cl.size=50)
```

