---
title: "scrattch.hicat"
author: "Zizhen Yao"
date: "2018-06-29"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Overview of Hierarchical Iterative Clustering for Analysis of Transcriptomics

The `scrattch.hicat` package offers functions to perform iterative clustering for single cell RNAseq datasets. 

The pipeline consists of the following key steps: 
* [Dataset formatting and setup](#setup)
* [Parameter specification](#params)
* [Dimension filtering based on QC correlation](#filter)
* [High variance gene selection and dimensionality reduction](#dimred)
* [Jaccard-Louvain or hierarchichal (Ward) clustering](#clust)
* [Cluster merging based on presence of differentially expressed genes.](#merge)  

This process is iteratively repeated within each resulting cluster until no more clusters meet differential gene expression and cluster size termination criteria. 

To obtain measures of clustering robustness, we perform consensus clustering:
* [Bootstrapping of the iterative clustering process](#boot)
* [Breakdown of consensus clustering](#breakdown)

Finally, we can inspect and visualize the results of consensus clustering:
* [Compute marker genes and plot marker heatmaps](#markerplot)
* [Hierarchical dendrograms](#dendplot)
* [t-SNE plots](#tsneplot)
* [Co-clustering heatmaps](#coclplot)

For this vignette, we use a subset of the dataset published in [Tasic, et al. (2016) Nature Neuroscience](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4985242/), which is available in the [tasic2016data package](https://github.com/AllenInstitute/tasic2016data):
```{r}
devtools::install_github("AllenInstitute/tasic2016data")
library(tasic2016data)
```

This vignette depends on a few other packages, in addition to `scrattch.hicat`:
```{r}
library(dendextend)
library(Matrix)
library(scrattch.hicat)
```

<a id="setup"></a>
## Dataset Formatting and Setup

First prepare the datasets 
```{r}
jet.colors <- colorRampPalette(c("#00007F", "#0000FF", "#007FFF", "#FF00FF", "#7FFF7F", "#FFFF00", "#FF7F00", "#FF0000", "#7F0000"))

# Load sample annotations (anno)
anno <- tasic_2016_anno

# Make a data.frame of unique cluster id, type, color, and broad type
ref.cl.df <- as.data.frame(unique(anno[,c("primary_type_id", "primary_type", "primary_type_color", "broad_type")]))

colnames(ref.cl.df)[1:3] <- c("cluster_id", "cluster_label", "cluster_color")

# Sort by cluster_id
ref.cl.df <- ref.cl.df[order(ref.cl.df$cluster_id),]
row.names(ref.cl.df) <- ref.cl.df$cluster_id

ref.cl <- setNames(factor(anno$primary_type_id), anno$sample_id)
```

Convert counts to CPM and take log2 transformation
```{r}
norm.dat <- log2(cpm(tasic_2016_counts)+1)
```

If you have a very large matrix, we recommend you convert it to a sparse matrix using the Matrix package to save memory:
```{r}
norm.dat <- cpm(Matrix(tasic_2016_counts, sparse = TRUE))

norm.dat@x <- log2(norm.dat@x+1)
```

For this demo, we'll select GABA-ergic neurons for clustering. 
```{r}
select.cells <- with(anno, sample_id[broad_type == "GABA-ergic Neuron" & primary_type!="unclassified"])
```

<a id="params"></a>
## Parameter specification

The final number of clusters produced by this iterative clustering algorithm is largely determined by the required cell type resolution specified by the user. The cell type resolution is defined by differential expression (DE) criteria between every pair of clusters. The users can specify these criteria ahead of time, for reuse in hicat functions by using the `de_param()` function. 

We compute statistical singificance of DE genes using `limma`, with two key parameters specified below:  
**padj.th**: adjusted p value threshold for DE genes.  
**lfc.th**: log2 fold change threshold for DE genes.  

We also require DE genes to have a relatively binary (on/off) expression pattern, specified by the following parameters:  
**low.th**: The minimum value used to determine whether a gene is detected in a given cell or not. This threshold is applied to log2-transformed, normalized data. The default value is 1. Users can specifiy different thresholds for different genes if necessary.  
For every pair of clusters (one as foreground, and the other as background), we define q1, and q2 as the proportion of cells with expression > **low.th** in the foregound and background cluster respectively.  
**q1.th**: For up regulated genes, q1 should be greater than q1.th in the *foreground* set.  
**q2.th**: For up regulated genes, q2 should be smaller than q2.th in the *background* set.  
**q.diff.th**: The difference, defined as abs(q1 - q2)/max(q1, q2) should be greater than q.diff.th.  
By default, **q1.th** = 0.5, **q2.th** = NULL, and **q.diff.th **= 0.7.  

The user can also ignore these parameters by setting them all to NULL.  
For high-depth datasets, like those generated using SMARTerV4 or Smart-Seq2, we recommend starting with **q1.th** = 0.5 .  
For low-depth datasets, like those generated using Dropseq or 10X Genomics, we recommend starting with **q1.th** = 0.3 due to the generally lower gene detection per cell in these datasets.  
When focusing on discrete cell types, set **q.diff.th** closer to 1.  
If splitting cell types based on graded or combinatorial differences in gene expression are of interest, adjust **q.diff.th** closer to 0.  
  
To determine whether two clusters are seperable based on DE genes, we define **de.score** as the sum of -log10(adjusted Pvalue) for all DE genes. Each gene contributes at most 20 towards the sum. All clusters should have pairwise de.score greater than **de.score.th**.  
For small datasets (#cells < 1000), we recommend **de.score.th** = 50.  
For large datasets (#cells > 10000), we recommend **de.score.th** = 150.  
```{r}
de.param <- de_param(padj.th     = 0.05, 
                     lfc.th      = 1, 
                     low.th      = 1, 
                     q1.th       = 0.5, 
                     q.diff.th   = 0.7, 
                     de.score.th = 50)
```

<a id="filter"></a>
## Dimension filtering based on QC correlation

Technical variation that should be masked during the clustering process can be specified using a matrix that we term **rm.eigen**. If batch effects are present, you can use the first principle component of batch-specific genes as a column in **rm.eigen**.  
QC-related factors, such as sequencing depth, gene detection limits, and fraction of reads mapped to transcriptome also tend to correlate with systemetic technical variation in gene expression.  
You can directly use proper transformation of these QC-related variables, or use the first principle component of the genes that correlate with these QC factors. The latter approach tends to work better with real datasets. When **rm.eigen** is specified, any reduced-dimension vectors during clustering that have correlation greater than **rm.th** with any columns of **rm.eigen** are ignored during clustering. 

We recommend that users to first explore their data by running the clustering pipeline without setting **rm.eigen**. If any batch specific or QC-driven clusters appear to cause problems, the user can create **rm.eigen** as demonstrated below, and rerun the pipeline. 

```{r,echo=FALSE}
gene.counts <- colSums(norm.dat > 0)
rm.eigen <- matrix(log2(gene.counts), ncol = 1)
row.names(rm.eigen) <- names(gene.counts)
colnames(rm.eigen) <- "log2GeneCounts"
```

<a id="dimred"></a>
## High variance gene selection and dimensionality reduction

<<<<<<< HEAD
Perform clustering using WGCNA for dimensional reduction. WGCNA mode is good for detecting rare clusters, provides cleaner cluster boundaries, while PCA is more scalable to large datasets, captures combinatorial marker expression pattern more effectively, and more sensitive to low depth dataset. We recommend using WGCNA for small high quality datasets, and PCA for large low coverage datasets. Note that WGCNA is considerably slower than PCA mode. The example we show here does not contain many cells, so we use WGCNA mode for better resolution.   

```{r, message=FALSE, warning=FALSE, results="hide"}
=======
`scrattch.hicat` can perform clustering using WGCNA or PCA for dimensionality reduction. WGCNA mode is good for detecting rare clusters and provides cleaner cluster boundaries, while PCA is more scalable to large datasets, captures combinatorial marker expression patterns more effectively, and is more sensitive to low-depth datasets.   
We recommend using WGCNA for smaller, high-depth datasets (< 4,000 samples; > 5,000 genes detecter per sample), and PCA for large or low-coverage datasets (> 4,000 samples or < 5,000 genes detected per sample). Another consideration is that WGCNA is considerably slower than PCA. The example we show here does not contain many cells, so we use WGCNA mode for better resolution.  
```{r, message=FALSE, warning=FALSE, results="hide", echo=FALSE}
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
set.seed(12345)
WGCNA.clust.result <- iter_clust(norm.dat, 
                                 select.cells = select.cells, 
                                 dim.method = "WGCNA", 
                                 de.param = de.param, 
                                 rm.eigen = rm.eigen)
```
To use PCA mode, simply set the **dim.method** parameter to "pca".  

<a id="clust"></a>
## Cluster merging based on presence of differentially expressed genes.

<<<<<<< HEAD
Although we checked whether clusters at any iteration can be seperated by DEG, clusters from different iterations can end up quite similar. So it is necessary to check whether all the clusters are seperable by DEGs in the end. 
Clusters that merged in the order defined by the nearest neighbors. Nearest neighbors are computed in a reduced dimension space defined by rd.dat. Here, we used the markers produced by iter_clust to define the reduced dimension. 
```{r, message=FALSE, warning=FALSE, result="hide"}
merge.result=merge_cl(norm.dat, WGCNA.clust.result$cl, rd.dat = t(norm.dat[WGCNA.clust.result$markers, select.cells]), de.param = de.param)
```

Compare and annotate the clusters based on reference cluster annotation. 
```{r}
compare.result=compare_annotate(merge.result$cl, ref.cl, ref.cl.df)
WGCNA.cl = compare.result$cl
WGCNA.cl.df = compare.result$cl.df
compare.result$g
=======
Throughout the iterative clustering process performed by `iter_clust()`, the function checked whether clusters at any iteration can be seperated by DEG. However, clusters from different iterations can end up very similar. Thus, it is necessary to check whether all the clusters are seperable by DEGs in the end. 
Clusters are merged in an order defined by the pairs of clusters that are nearest neighbors, which are computed in a reduced dimension space defined by **rd.dat**.  
Here, we use the set of markers produced by `iter_clust()` to define the reduced dimensions:
```{r, message=FALSE, warning=FALSE, result="hide", echo=FALSE}
rd.dat <- t(norm.dat[WGCNA.clust.result$markers, select.cells])

merge.result <- merge_cl(norm.dat, 
                         WGCNA.clust.result$cl, 
                         rd.dat = rd.dat, 
                         de.param = de.param)
```

In this demo, we have previously derived cluster labels from Tasic, et al. (2016). To see how these cluster calls match up to those generated by `scrattch.hicat`, we can compare and annotate the clusters based on the reference cluster annotation. 
```{r, echo=FALSE}
compare.result <- compare_annotate(merge.result$cl, ref.cl, ref.cl.df)
compare.result$g
WGCNA.cl <- compare.result$cl
WGCNA.cl.df <- compare.result$cl.df
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
```

<a id="boot"></a>
## Bootstrapping for Consensus clustering

The iterative clustering pipeline tends to produce many clusters, with increased uncertainty as we try to split the clusters at finer resolution. Therefore, it is important to assess the robustness of clustering results. We address this problem by performing clustering many times on 80% of randomly subsampled cells, keep track of how often each cell is clustered with each other cell (a cell-cell co-clustering matrix), and use these frequencies of cell-cell co-clustering to infer consensus clustering. We also compute statistics to evaluate our confidence in the seperation between every pair of consensus clusters.

<<<<<<< HEAD
```{r}
=======
`run_consensus_clust()` is a convenient wrapper function for performing this bootstrapped, iterative clustering process:
```{r, echo=FALSE}
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
set.seed(12345)
result <- run_consensus_clust(norm.dat[,select.cells], 
                              niter = 20, 
                              de.param = de.param, 
                              rm.eigen = rm.eigen, 
                              dim.method = "WGCNA", 
                              output_dir = "subsample_WGCNA")
```

<<<<<<< HEAD

If you have a multi-core computer, this function can be run in parallel by setting mc.cores to the number of cores you can use. Please try using small number of cpus first to monitor the momery consumption.  
```{r, eval=FALSE}
result <- run_consensus_clust(norm.dat, niter=50, de.param =de.param, rm.eigen=rm.eigen, dim.method="WGCNA", mc.cores=4)
```

run_consensus_clust is a wrapper function that performs the following tasks:  

- Perform clustering on subsampled cells
```{r,eval=FALSE}
d = paste0("subsample_WGCNA")
dir.create(d)
all.cells=select.cells
subsample.result = sapply(1:20,function(i){
  prefix=paste0("iter",i)
  tmp.cells = sample(all.cells, round(0.8*length(all.cells)))
  result <- iter_clust(norm.dat, select.cells=tmp.cells, prefix=prefix, dim.method="WGCNA", de.param = de.param)
  save(result, file=file.path(d, paste0("result.",i,".rda")))
})
```

- Collect cell-cell co-clustering probablities.
```{r, eval=FALSE}
result.files=file.path(d, dir(d, "result.*.rda"))
=======
If you have a multi-core computer, this function can be run in parallel by setting **mc.cores** to the number of cores you can use.  
Note that this can result in high memory consumption with a high number of parallel processes. Try using small number of cores first to monitor the memory consumption:
```{r, eval=FALSE, echo=FALSE}
result <- run_consensus_clust(norm.dat, 
                              niter = 50, 
                              de.param = de.param, 
                              rm.eigen = rm.eigen, 
                              dim.method = "WGCNA", 
                              output_dir = "subsample_WGCNA", 
                              mc.cores = 4)
```

As with the single-iteration clustering, we can compare the consensus clustering results with the reference clusters:
```{r, echo=FALSE}
compare.result <- compare_annotate(result$cl.result$cl, ref.cl, ref.cl.df)
compare.result$g
cl <- compare.result$cl
cl.df <- compare.result$cl.df
```

<a id="breakdown"></a>
## Consensus clustering process

`run_consensus_clust()` is a wrapper function that performs the following steps:  
- Perform clustering on subsampled cells:
```{r, echo=FALSE, eval=FALSE}
d <- paste0("subsample_WGCNA")
dir.create(d)
all.cells <- select.cells
subsample.result <- sapply(1:50, 
                           function(i) {
                             prefix <- paste0("iter",i)
                             tmp.cells <- sample(all.cells, round(0.8 * length(all.cells)))
                             result <- iter_clust(norm.dat, 
                                                  select.cells = tmp.cells, 
                                                  prefix = prefix, 
                                                  dim.method = "WGCNA", 
                                                  de.param = de.param)
                             save(result, file = file.path(d, paste0("result.", i, ".rda")))
                           }
)
```

- Collect cell-cell co-clustering probablities:
```{r, echo=FALSE, eval=FALSE}
result.files <- file.path(d, dir(d, "result.*.rda"))
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
co.result <- collect_co_matrix_sparseM(norm.dat, result.files, all.cells)
co.ratio <- co.result$co.ratio
cl.list <- co.result$cl.list
```

<<<<<<< HEAD
- Infer consensus clusters based on cell cell co-clustering matrix.
```{r, eval=FALSE}
consensus.result = iter_consensus_clust(co.ratio, cl.list, norm.dat, select.cells=select.cells, de.param=de.param)
=======
- Infer consensus clusters based on the cell-cell co-clustering matrix:
```{r, echo=FALSE, eval=FALSE}
consensus.result <- iter_consensus_clust(co.ratio, 
                                         cl.list, 
                                         norm.dat, 
                                         select.cells = select.cells, 
                                         de.param = de.param)
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
```

- Adjust cluster boundaries to optimize within-cluster co-clustering probabilties:
```{r, echo=FALSE, eval= FALSE}
refine.result <- refine_cl(consensus.result$cl, 
                           co.ratio = co.ratio, 
                           tol.th = 0.005, 
                           confusion.th = 0.8)
```

- Double-check if all clusters are separable based on DE genes again:
```{r, echo=FALSE, eval=FALSE}
merge.result <- merge_cl(norm.dat, 
                         refine.result$cl, 
                         rd.dat = t(norm.dat[consensus.result$markers,select.cells]), 
                         de.param = de.param)
```

<<<<<<< HEAD


Compare the consensus clustering result with the reference clusters
```{r, echo=FALSE}
compare.result=compare_annotate(result$cl.result$cl, ref.cl, ref.cl.df)
cl = compare.result$cl
cl.df = compare.result$cl.df
compare.result$g
```

=======
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
At this point,  check the cluster annotation cl.df manually to change the cluster labels, colors, and determine if some clusters are outliers. 
If there are outlier clusters, define cl.clean as the clusters after removing outliers.
```{r}
cl.clean <- droplevels(cl)
```

<a id="markerplot"></a>
## Marker genes and heatmaps

<<<<<<< HEAD

Compute DE genes between every pair of clusters, and plot the heatmap using top 20 DE genes between every pair. If you have many clusters, the heatmap will be very large. Choose small number of n.markers, and use "max.cl.size" to sample subsets of cells for plotting.  
```{r, warning=FALSE, message=FALSE}
display.result=display_cl(cl.clean, norm.dat,  plot=TRUE, n.markers=20)
de.genes = display.result$de.genes
=======
Compute DE genes between every pair of clusters, and plot the heatmap using the top 20 DE genes between every pair.  
If you have many clusters, the heatmap will be very large. Choose a small number of **n.markers**, and **max.cl.size** to sample subsets of cells for plotting.  
```{r}
display.result <- display_cl(cl.clean, 
                             norm.dat, 
                             n.markers = 20, 
                             plot = TRUE)
de.genes <- display.result$de.genes
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
```

<a id="dendplot"></a>
## Hierarchical dendrograms

<<<<<<< HEAD

Build dendrogram for clusters using the cluster-cluster correlation matrix based on cluster medians of the top 50 genes between every pair of clusters
```{r, message=FALSE, results="hide"}
select.markers = select_markers(norm.dat, cl.clean, n.markers=50, de.genes=de.genes)$markers
cl.med = get_cl_medians(norm.dat[select.markers,], cl.clean)
=======
Build dendrogram for clusters using the cluster-cluster correlation matrix based on cluster medians of the top 50 genes between every pair of clusters with `select_markers()` and `build_dend()`:
```{r, echo=FALSE}
select.markers <- select_markers(norm.dat, 
                                 cl, 
                                 n.markers = 50, 
                                 de.genes = de.genes)$markers
cl.med <- get_cl_medians(norm.dat[select.markers,], cl)
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
##The prefered order for the leaf nodes.
l.rank <- setNames(1:nrow(cl.df), row.names(cl.df))
##Color of the leaf nodes.
<<<<<<< HEAD
l.color = setNames(as.character(cl.df$cluster_color),row.names(cl.df))
dend.result <- build_dend(cl.med[,levels(cl.clean)],l.rank, l.color,nboot=100)
=======
l.color <- setNames(as.character(cl.df$cluster_color), row.names(cl.df))
dend.result <- build_dend(cl.med[,levels(cl.clean)],
                          l.rank, 
                          l.color,
                          nboot = 100)
dend <- dend.result$dend
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
```


Reorder the clusters based on the dendrogram:
```{r}
<<<<<<< HEAD
dend= dend.result$dend
cl.clean = setNames(factor(as.character(cl.clean), levels=labels(dend)), names(cl.clean))
cl.df.clean =cl.df[levels(cl.clean),]
```

Plot the dendrogram and cluster-cluster correlation matrix:
```{r, fig.keep="all"}
library(dendextend)
labels(dend) = cl.df[labels(dend),"cluster_label"]
cl.cor = dend.result$cl.cor
row.names(cl.cor) = colnames(cl.cor) = cl.df[row.names(cl.cor),"cluster_label"]
=======
cl.clean <- setNames(factor(as.character(cl.clean), levels = labels(dend)), names(cl.clean))
cl.df.clean <- cl.df[levels(cl.clean),]
```

Plot the dendrogram and cluster-cluster correlation matrix:
```{r, echo=FALSE, fig.keep="all"}
labels(dend) <- cl.df[labels(dend), "cluster_label"]
cl.cor <- dend.result$cl.cor
row.names(cl.cor) <- colnames(cl.cor) <- cl.df[row.names(cl.cor), "cluster_label"]
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
plot(dend)
heatmap.3(cl.cor, 
          Rowv = dend, Colv = dend, 
          trace = "none", col = jet.colors(100),
          cexCol = 0.5, cexRow = 0.5,
          breaks = c(-0.2, 0.2, seq(0.2, 1, length.out = 99)))
```

<a id="tsneplot"></a>
## t-SNE plots

Generate t-SNE coordinates and a plot using `plot_tsne_cl()`:
```{r,fig.keep="all"}
tsne.result <- plot_tsne_cl(norm.dat, select.markers, cl.clean, cl.df)
tsne.result$g
```

Plot expression of a set of genes using the t-SNE coordinates with `plot_tsne_gene()`:
```{r}
tsne.df <- tsne.result$tsne.df
markers <- c("Slc17a7","Gad2","Sst","Chodl","Myh8","Pvalb","Vip","6330527O06Rik","Sncg","Cxcl14")
gene.plots <- plot_tsne_gene(tsne.df, norm.dat, markers)
multiplot(plotlist = gene.plots, cols = 5)
```

<<<<<<< HEAD


Plot the heatmap of co-clustering matrix. To reduce the size of image, randomly sampled up to 50 cells per cluster
```{r, warning=FALSE, message=FALSE}
co.ratio = result$co.result$co.ratio
tmp=plot_co_matrix(co.ratio, cl.clean, max.cl.size=50)
=======
<a id="coclplot"></a>
## Co-clustering matrix heatmap

Plot the heatmap of co-clustering matrix with `plot_co_matrix()`.  
To reduce the size of image, we randomly sample up to 50 cells per cluster with **max.cl.size**:
```{r}
co.ratio <- result$co.result$co.ratio
tmp <- plot_co_matrix(co.ratio, cl.clean, max.cl.size = 50)
>>>>>>> 5b114d8784c068f2b9deb15cbf15eabcc249f5d3
```

