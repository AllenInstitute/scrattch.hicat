---
title: "scrattch.hicat"
author: "Zizhen Yao"
date: "2018-06-29"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

The scrattch.hicat package offers functions to perform iterative clustering for single cell RNAseq datasets. 

The pipeline consists of the following key steps: 
* Dataset formatting and setup
* Parameter specification
* Dimension filtering based on QC correlation
* High variance gene selection and dimensionality reduction
* Jaccard-Louvain or hierarchichal (Ward) clustering
* Cluster merging based on presence of differentially expressed genes. 

This process is iteratively repeated within each resulting cluster until no more clusters meet differential gene expression and cluster size termination criteria. 

For this vignette, we use a subset of the dataset published in [Tasic, et al. (2016) Nature Neuroscience](), which is available in the tasic2016data package:
```{r}
devtools::install_github("AllenInstitute/tasic2016data")
library(tasic2016data)
```

This vignette depends on a few other packages, in addition to scrattch.hicat:
```{r}
library(dendextend)
library(Matrix)
library(scrattch.hicat)
```

## Dataset Formatting and Setup

First prepare the datasets 
```{r}
jet.colors <- colorRampPalette(c("#00007F", "#0000FF", "#007FFF", "#FF00FF", "#7FFF7F", "#FFFF00", "#FF7F00", "#FF0000", "#7F0000"))

# Load sample annotations (anno)
anno <- tasic_2016_anno

# Make a data.frame of unique cluster id, type, color, and broad type
ref.cl.df <- as.data.frame(unique(anno[,c("primary_type_id", "primary_type", "primary_type_color", "broad_type")]))

colnames(ref.cl.df)[1:3] <- c("cluster_id", "cluster_label", "cluster_color")

# Sort by cluster_id
ref.cl.df <- ref.cl.df[order(ref.cl.df$cluster_id),]
row.names(ref.cl.df) <- ref.cl.df$cluster_id

ref.cl <- setNames(factor(anno$primary_type_id), anno$sample_id)
```

Convert counts to CPM and take log2 transformation
```{r}
norm.dat <- log2(cpm(tasic_2016_counts)+1)
```

If you have a very large matrix, we recommend you convert it to a sparse matrix using the Matrix package to save memory:
```{r}
norm.dat <- cpm(Matrix(tasic_2016_counts, sparse = TRUE))

norm.dat@x <- log2(norm.dat@x+1)
```

For this demo, we'll select GABA-ergic neurons for clustering. 
```{r}
select.cells <- with(anno, sample_id[broad_type == "GABA-ergic Neuron" & primary_type!="unclassified"])
```

## Parameter specification

The final number of clusters produced by this iterative clustering algorithm is largely determined by the required cell type resolution specified by the user. The cell type resolution is defined by differential expression (DE) criteria between every pair of clusters. The users can specify these criteria ahead of time, for reuse in hicat functions by using the `de_param()` function. 

We compute statistical singificance of DE genes using `limma`, with two key parameters specified below:  
**padj.th**: adjusted p value threshold for DE genes.  
**lfc.th**: log2 fold change threshold for DE genes.  

We also require DE genes to have a relatively binary (on/off) expression pattern, specified by the following parameters:  
**low.th**: The minimum value used to determine whether a gene is detected in a given cell or not. This threshold is applied to log2-transformed, normalized data. The default value is 1. Users can specifiy different thresholds for different genes if necessary.  
For every pair of clusters (one as foreground, and the other as background), we define q1, and q2 as the proportion of cells with expression > **low.th** in the foregound and background cluster respectively.  
**q1.th**: For up regulated genes, q1 should be greater than q1.th in the *foreground* set.  
**q2.th**: For up regulated genes, q2 should be smaller than q2.th in the *background* set.  
**q.diff.th**: The difference, defined as abs(q1 - q2)/max(q1, q2) should be greater than q.diff.th.  
By default, **q1.th** = 0.5, **q2.th** = NULL, and **q.diff.th **= 0.7.  

The user can also ignore these parameters by setting them all to NULL.  
For high-depth datasets, like those generated using SMARTerV4 or Smart-Seq2, we recommend starting with **q1.th** = 0.5 .  
For low-depth datasets, like those generated using Dropseq or 10X Genomics, we recommend starting with **q1.th** = 0.3 due to the generally lower gene detection per cell in these datasets.  
When focusing on discrete cell types, set **q.diff.th** closer to 1.  
If splitting cell types based on graded or combinatorial differences in gene expression are of interest, adjust **q.diff.th** closer to 0.  
  
To determine whether two clusters are seperable based on DE genes, we define **de.score** as the sum of -log10(adjusted Pvalue) for all DE genes. Each gene contributes at most 20 towards the sum. All clusters should have pairwise de.score greater than **de.score.th**.  
For small datasets (#cells < 1000), we recommend **de.score.th** = 50.  
For large datasets (#cells > 10000), we recommend **de.score.th** = 150.  
```{r}
de.param <- de_param(padj.th     = 0.05, 
                     lfc.th      = 1, 
                     low.th      = 1, 
                     q1.th       = 0.5, 
                     q.diff.th   = 0.7, 
                     de.score.th = 50)
```

## Dimension filtering based on QC correlation

Technical variation that should be masked during the clustering process can be specified using a matrix that we term **rm.eigen**. If batch effects are present, you can use the first principle component of batch-specific genes as a column in **rm.eigen**.  
QC-related factors, such as sequencing depth, gene detection limits, and fraction of reads mapped to transcriptome also tend to correlate with systemetic technical variation in gene expression.  
You can directly use proper transformation of these QC-related variables, or use the first principle component of the genes that correlate with these QC factors. The latter approach tends to work better with real datasets. When **rm.eigen** is specified, any reduced-dimension vectors during clustering that have correlation greater than **rm.th** with any columns of **rm.eigen** are ignored during clustering. 

We recommend that users to first explore their data by running the clustering pipeline without setting **rm.eigen**. If any batch specific or QC-driven clusters appear to cause problems, the user can create **rm.eigen** as demonstrated below, and rerun the pipeline. 

```{r,echo=FALSE}
gene.counts <- colSums(norm.dat > 0)
rm.eigen <- matrix(log2(gene.counts), ncol = 1)
row.names(rm.eigen) <- names(gene.counts)
colnames(rm.eigen) <- "log2GeneCounts"
```

## High variance gene selection and dimensionality reduction

`scrattch.hicat` can perform clustering using WGCNA or PCA for dimensionality reduction. WGCNA mode is good for detecting rare clusters and provides cleaner cluster boundaries, while PCA is more scalable to large datasets, captures combinatorial marker expression patterns more effectively, and is more sensitive to low-depth datasets.   
We recommend using WGCNA for smaller, high-depth datasets (< 4,000 samples; > 5,000 genes detecter per sample), and PCA for large or low-coverage datasets (> 4,000 samples or < 5,000 genes detected per sample). Another consideration is that WGCNA is considerably slower than PCA. The example we show here does not contain many cells, so we use WGCNA mode for better resolution.  
```{r, message=FALSE, warning=FALSE, results="hide", echo=FALSE}
set.seed(12345)
WGCNA.clust.result <- iter_clust(norm.dat, 
                                 select.cells = select.cells, 
                                 dim.method = "WGCNA", 
                                 de.param = de.param, 
                                 rm.eigen = rm.eigen)
```
To use PCA mode, simply set the **dim.method** parameter to "pca".  


Throughout the iterative clustering process performed by `iter_clust()`, the function checked whether clusters at any iteration can be seperated by DEG. However, clusters from different iterations can end up very similar. Thus, it is necessary to check whether all the clusters are seperable by DEGs in the end. 
Clusters that merged in the order defined by the nearest neighbors. Nearest neighbors are computed in a reduced dimension space defined by rd.dat. Here, we used the markers produced by iter_clust to define the reduced dimension. 
```{r, message=FALSE, warning=FALSE, result="hide", echo=FALSE}
merge.result <- merge_cl(norm.dat, 
                         WGCNA.clust.result$cl, 
                         rd.dat = t(norm.dat[WGCNA.clust.result$markers, select.cells]), 
                         de.param = de.param)
```

Compare and annotate the clusters based on reference cluster annotation. 
```{r, echo=FALSE}
compare.result <- compare_annotate(merge.result$cl, ref.cl, ref.cl.df)
compare.result$g
WGCNA.cl <- compare.result$cl
WGCNA.cl.df <- compare.result$cl.df
```


Iterative clustering pipeline tend to produce many clusters, and uncertainty increases as we try to split the clusters at finer resolution. Therefore, it is important to assess the robustness of clustering result. We solve this problem by performing clustering many times on 80% of subsampled cells, compute cell-cell co-clustering matrix, and finally infer consensus clustering. We also compute statistics to eveluate confidence of seperation between every pair of consensus clusters.


```{r, echo=FALSE}
set.seed(12345)
result <- run_consensus_clust(norm.dat[,select.cells], 
                              niter = 20, 
                              de.param = de.param, 
                              rm.eigen = rm.eigen, 
                              dim.method = "WGCNA", 
                              output_dir = "subsample_WGCNA")
```


If you have a multi-core computer, this function can be run in parallel by setting mc.cores to the number of cores you can use. Please try using small number of cpus first to monitor the momery consumption.  
```{r, eval=FALSE, echo=FALSE}
result <- run_consensus_clust(norm.dat, 
                              niter = 50, 
                              de.param = de.param, 
                              rm.eigen = rm.eigen, 
                              dim.method = "WGCNA", 
                              output_dir = "subsample_WGCNA", 
                              mc.cores = 4)
```

Compare the consensus clustering result with the reference clusters
```{r, echo=FALSE}
compare.result <- compare_annotate(result$cl.result$cl, ref.cl, ref.cl.df)
compare.result$g
cl <- compare.result$cl
cl.df <- compare.result$cl.df
```

run_consensus_clust is a wrapper function that performs the following tasks:
- Perform clustering on subsampled cells
```{r, echo=FALSE, eval=FALSE}
d <- paste0("subsample_WGCNA")
dir.create(d)
all.cells <- select.cells
subsample.result <- sapply(1:50, 
                           function(i) {
                             prefix <- paste0("iter",i)
                             tmp.cells <- sample(all.cells, round(0.8 * length(all.cells)))
                             result <- iter_clust(norm.dat, 
                                                  select.cells = tmp.cells, 
                                                  prefix = prefix, 
                                                  dim.method = "WGCNA", 
                                                  de.param = de.param)
                             save(result, file = file.path(d, paste0("result.", i, ".rda")))
                           }
)
```

- Collect cell-cell co-clustering probablities.
```{r, echo=FALSE, eval=FALSE}
result.files <- file.path(d, dir(d, "result.*.rda"))
co.result <- collect_co_matrix_sparseM(norm.dat, result.files, all.cells)
co.ratio <- co.result$co.ratio
cl.list <- co.result$cl.list
```

- Infer consensus clusters based on cell cell co-clustering matrix.
```{r, echo=FALSE, eval=FALSE}
consensus.result <- iter_consensus_clust(co.ratio, 
                                         cl.list, 
                                         norm.dat, 
                                         select.cells = select.cells, 
                                         de.param = de.param)
```

- Adjust cluster boundaries to optimize with-in cluster co-clustering probabilties
```{r, echo=FALSE, eval= FALSE}
refine.result <- refine_cl(consensus.result$cl, 
                           co.ratio = co.ratio, 
                           tol.th = 0.005, 
                           confusion.th = 0.8)
```

- Double check if all clusters are separable based on DEG genes again. 
```{r, echo=FALSE, eval=FALSE}
merge.result <- merge_cl(norm.dat, 
                         refine.result$cl, 
                         rd.dat = t(norm.dat[consensus.result$markers,select.cells]), 
                         de.param = de.param)
```



At this point,  check the cluster annotation cl.df manually to change the cluster labels, colors, and determine if some clusters are outliers. 
If there are outlier clusters, define cl.clean as the clusters after removing outliers. 
```{r}
cl.clean <- droplevels(cl)
```



Compute DE genes between every pair of clusters, and plot the heatmap using top 20 DE genes between every pair. If you have many clusters, the heatmap will be very large. Choose small number of n.markers, and use "max.cl.size" to sample subsets of cells for plotting.  
```{r}
display.result <- display_cl(cl.clean, 
                             norm.dat, 
                             n.markers = 20, 
                             plot = TRUE)
de.genes <- display.result$de.genes
```



Build dendrogram for clusters using the cluster-cluster correlation matrix based on cluster medians of the top 50 genes between every pair of clusters
```{r, echo=FALSE}
select.markers <- select_markers(norm.dat, 
                                 cl, 
                                 n.markers = 50, 
                                 de.genes = de.genes)$markers
cl.med <- get_cl_medians(norm.dat[select.markers,], cl)
##The prefered order for the leaf nodes.
l.rank <- setNames(1:nrow(cl.df), row.names(cl.df))
##Color of the leaf nodes.
l.color <- setNames(as.character(cl.df$cluster_color), row.names(cl.df))
dend.result <- build_dend(cl.med[,levels(cl.clean)],
                          l.rank, 
                          l.color,
                          nboot = 100)
dend <- dend.result$dend
```

Reorder the clusters based on the dendrogram:
```{r}
cl.clean <- setNames(factor(as.character(cl.clean), levels = labels(dend)), names(cl.clean))
cl.df.clean <- cl.df[levels(cl.clean),]
```

Plot the dendrogram and cluster-cluster correlation matrix:
```{r, echo=FALSE, fig.keep="all"}
labels(dend) <- cl.df[labels(dend), "cluster_label"]
cl.cor <- dend.result$cl.cor
row.names(cl.cor) <- colnames(cl.cor) <- cl.df[row.names(cl.cor), "cluster_label"]
plot(dend)
heatmap.3(cl.cor, 
          Rowv = dend, Colv = dend, 
          trace = "none", col = jet.colors(100),
          cexCol = 0.5, cexRow = 0.5,
          breaks = c(-0.2, 0.2, seq(0.2, 1, length.out = 99)))
```


Create tSNE plots:
```{r,fig.keep="all"}
tsne.result <- plot_tsne_cl(norm.dat, select.markers, cl, cl.df)
tsne.result$g
```

Plot gene expression on tSNE
```{r}
tsne.df <- tsne.result$tsne.df
markers <- c("Slc17a7","Gad2","Sst","Chodl","Myh8","Pvalb","Vip","6330527O06Rik","Sncg","Cxcl14")
gene.plots <- plot_tsne_gene(tsne.df, norm.dat, markers)
multiplot(plotlist = gene.plots, cols = 5)
```

Plot the heatmap of co-clustering matrix. To reduce the size of image, randomly sampled up to 50 cells per cluster
```{r}
co.ratio <- result$co.result$co.ratio
tmp <- plot_co_matrix(co.ratio, cl.clean, max.cl.size = 50)
```

